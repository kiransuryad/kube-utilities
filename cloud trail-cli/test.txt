Steps to Set Up a Dedicated Namespace

kubectl create namespace vault-auth
kubectl create serviceaccount vault-auth-setup -n vault-auth
Then retrieve the values for Vault:

JWT_TOKEN=$(kubectl create token vault-auth-setup -n vault-auth)
K8S_CA_CERT=$(kubectl get configmap kube-root-ca.crt -n vault-auth -o jsonpath="{.data.ca\.crt}")
K8S_HOST=$(kubectl config view --minify -o jsonpath="{.clusters[0].cluster.server}")


---
Updated Steps (Child Namespace Scope)

Here’s what you need to do next:

1. ✅ Enable Kubernetes Auth within your namespace
vault auth enable -path=kubernetes kubernetes
This enables the Kubernetes auth backend scoped to your namespace.

2. ✅ Configure the Kubernetes Auth Backend
Now the previous vault write should work:

vault write auth/kubernetes/config \
  token_reviewer_jwt="${JWT_TOKEN}" \
  kubernetes_host="${K8S_HOST}" \
  kubernetes_ca_cert="${K8S_CA_CERT}" \
  issuer="https://kubernetes.default.svc"
✅ This will succeed now because you’re operating inside your own namespace.

3. ✅ Continue with the Role + Secret Setup
vault write auth/kubernetes/role/k8s-general \
  bound_service_account_names="*" \
  bound_service_account_namespaces="*" \
  policies="k8s-read-eks-apps" \
  ttl="24h"

vault kv put eks-apps/prod/keycloak/admin username="admin" password="supersecret123"

---
Update your Vault policy to include this:

# file: vault-admin-k8s-setup.hcl

# For setting up Kubernetes auth backend
path "auth/kubernetes/config" {
  capabilities = ["create", "update"]
}

# For creating roles that map K8s SAs to policies
path "auth/kubernetes/role/*" {
  capabilities = ["create", "update", "read", "delete", "list"]
}
Then apply:

vault policy write vault-admin-k8s-setup vault-admin-k8s-setup.hcl

----
#!/bin/bash

set -e

VAULT_ADDR="${VAULT_ADDR:-http://127.0.0.1:8200}"
VAULT_NAMESPACE="${VAULT_NAMESPACE:-root}"

ENGINE_PATH="eks-apps"
POLICY_NAME="k8s-read-eks-apps"
ROLE_NAME="k8s-general"

echo "🔐 [1/6] Enabling new KV v2 secrets engine at path: ${ENGINE_PATH}/"

vault secrets enable -path="${ENGINE_PATH}" -version=2 kv || echo "🟡 Already enabled"

echo "📜 [2/6] Writing Vault policy: ${POLICY_NAME}"

cat <<EOF | vault policy write ${POLICY_NAME} -
path "${ENGINE_PATH}/data/*" {
  capabilities = ["read"]
}
EOF

echo "🔑 [3/6] Extracting Kubernetes auth details from cluster..."

JWT_TOKEN=$(kubectl get secret $(kubectl get sa default -n default -o jsonpath="{.secrets[0].name}") -n default -o jsonpath="{.data.token}" | base64 -d)
K8S_HOST=$(kubectl config view --minify -o jsonpath="{.clusters[0].cluster.server}")
K8S_CA_CERT=$(kubectl get secret $(kubectl get sa default -n default -o jsonpath="{.secrets[0].name}") -n default -o jsonpath="{.data['ca\.crt']}" | base64 -d)

echo "⚙️ [4/6] Configuring Vault Kubernetes auth backend"

vault write auth/kubernetes/config \
  token_reviewer_jwt="${JWT_TOKEN}" \
  kubernetes_host="${K8S_HOST}" \
  kubernetes_ca_cert="${K8S_CA_CERT}" \
  issuer="https://kubernetes.default.svc"

echo "🔗 [5/6] Creating Vault role: ${ROLE_NAME} (bound to all SAs & namespaces)"

vault write auth/kubernetes/role/${ROLE_NAME} \
  bound_service_account_names="*" \
  bound_service_account_namespaces="*" \
  policies="${POLICY_NAME}" \
  ttl="24h"

echo "🔐 [6/6] Storing a sample secret at: ${ENGINE_PATH}/prod/keycloak/admin"

vault kv put ${ENGINE_PATH}/prod/keycloak/admin username="admin" password="supersecret123"

echo "✅ Vault Kubernetes integration complete!"




--------
Quick Test Plan — Certificate Issuance

📄 Step 1: Create a Test Certificate Resource
Here’s a simple manifest that will request a TLS cert using your cio-ca-issuer.

# test-certificate.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: test-tls
  namespace: default
spec:
  secretName: test-tls-secret
  duration: 2160h # 90 days
  renewBefore: 360h # 15 days
  commonName: test.keycloak.internal
  dnsNames:
    - test.keycloak.internal
  issuerRef:
    name: cio-ca-issuer
    kind: ClusterIssuer
Apply it:

kubectl apply -f test-certificate.yaml
🔍 Step 2: Validate Certificate Status
Check if cert-manager successfully issued it:

kubectl get certificate test-tls -n default
Expected output:

NAME        READY   SECRET             AGE
test-tls    True    test-tls-secret    1m
If READY is not True, inspect events:

kubectl describe certificate test-tls -n default
kubectl get events -n default --sort-by=.metadata.creationTimestamp
🔐 Step 3: Inspect the Generated Secret
kubectl get secret test-tls-secret -n default -o yaml
Should contain:

tls.crt → Certificate
tls.key → Private key
Optional: Decode and inspect the certificate:

kubectl get secret test-tls-secret -n default -o jsonpath='{.data.tls\.crt}' | base64 -d | openssl x509 -noout -text
Check:

CN = test.keycloak.internal
Validity period = 90 days
Issuer = cio.internal

-----
chart.yaml
---

apiVersion: v2
name: cert-bootstrap
description: Bootstrap internal self-signed CA and ClusterIssuer for cert-manager
type: application
version: 0.1.0
appVersion: "1.0"


vaules.yaml
-----

bootstrapCerts:
  enabled: true
  caCommonName: "cio.internal"
  duration: "8760h"         # 1 year
  renewBefore: "720h"       # 30 days
  caSecretName: "cio-internal-ca-secret"
  clusterIssuerName: "cio-ca-issuer"
  certificateName: "cio-internal-ca"
  namespace: "cert-manager"




-----

---
selfsigned-cluster-issuer.yaml
---
{{- if .Values.bootstrapCerts.enabled }}
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-cluster-issuer
spec:
  selfSigned: {}
{{- end }}


------

----
cio-ca-certificate.yaml
----

{{- if .Values.bootstrapCerts.enabled }}
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: cio-internal-ca
  namespace: cert-manager
spec:
  isCA: true
  commonName: "{{ .Values.bootstrapCerts.caCommonName }}"
  secretName: "{{ .Values.bootstrapCerts.caSecretName }}"
  duration: {{ .Values.bootstrapCerts.duration | quote }}
  renewBefore: {{ .Values.bootstrapCerts.renewBefore | quote }}
  issuerRef:
    name: selfsigned-cluster-issuer
    kind: ClusterIssuer
{{- end }}


------

----
cio-ca-issuer.yaml
----

{{- if .Values.bootstrapCerts.enabled }}
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: {{ .Values.bootstrapCerts.clusterIssuerName }}
spec:
  ca:
    secretName: "{{ .Values.bootstrapCerts.caSecretName }}"
{{- end }}

