{{- if .Values.secrets.envFromSecrets }}
envFrom:
{{- range .Values.secrets.envFromSecrets }}
  {{- if . }}
  - secretRef:
      name: {{ . | quote }}
  {{- end }}
{{- end }}
{{- end }}


--

secrets:
  envFromSecrets:
    - vault-token




----------------
#!/bin/bash
set -euo pipefail

echo "Ensuring Vault token Kubernetes secret exists..."

# Retrieve Vault token from Harness secret (backed by Vault)
VAULT_TOKEN="<+secrets.getValue('vault-token-uat-ethos-portal')>"

# Target namespace (from Harness infra)
NAMESPACE="<+infra.namespace>"

SECRET_NAME="vault-token"

# Apply or update the Kubernetes secret
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: ${SECRET_NAME}
  namespace: ${NAMESPACE}
type: Opaque
stringData:
  token: "${VAULT_TOKEN}"
EOF

echo "Vault token secret '${SECRET_NAME}' ensured in namespace '${NAMESPACE}'."


--

env:
  - name: VAULT_TOKEN
    valueFrom:
      secretKeyRef:
        name: vault-token
        key: token








-----------------------------
vault status
vault token lookup
vault secrets list | head

Create eks-java-read.hcl:
# Allow reading secret values (KV v2)
path "uat-ethos-portal-backend/data/*" {
  capabilities = ["read"]
}

# Allow listing and reading metadata (KV v2)
path "uat-ethos-portal-backend/metadata/*" {
  capabilities = ["list", "read"]
}


vault policy write eks-java-read eks-java-read.hcl

vault token create \
  -display-name="eks-java-uat-ethos-portal" \
  -policy="eks-java-read" \
  -ttl="8760h" \
  -orphan



# Check global caps
vault read sys/config/state/sanitized | egrep -i "default_lease_ttl|max_lease_ttl"

# Check token auth tune
vault read sys/auth/token/tune

